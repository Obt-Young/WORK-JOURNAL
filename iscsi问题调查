基本知识：
•	Iscsi由两部分组成：initator 和 target
•	Initator为客户端，target为服务端
•	Initator所属代码在工程open-iscsi-master中
•	Target所属代码在工程iscsitarget中

问题描述：
见邮件
注：邮件中 100.0.0.1 为initator（客户端）， 100.0.0.2 为target（服务端）

问题小结：
从服务端在回应客户端上一个IO请求且客户端已收到，到客户端发出下一个IO请求，这中间的时间过长。
考虑从客户端的逻辑来追踪时间消耗在什么地方。

分析：
1.	iscsi的基本传输单元为PDU（Protocal Data Unit），wireshark中每一行代表一个IP层的packet包，结合图片描述，可猜测对应关系为  1个PDU = n个packet  。
2.	目前现象为，客户端在收到服务端针对本次IO的最后一个PDU后，没有快速做出响应，而是迟疑了约10ms才发出随后的PDU。
3.	如果1个PDU = n个packet的猜测是正确的，那么问题就出在PDU之间的衔接上，而这种衔接的“断档”恰恰出现在客户端，即initator。
4.	我们现在就从接收PDU并处理PDU的相关函数入手。
打开open-iscsi-master工程，查找接收pdu的相关函数，可以找到如下调用顺序（堆结构罗列）：
1.	事件触发
2.	 
3.	 
4.	 

原邮件内容：
发件人: chengyu (D) 
发送时间: 2018年3月3日 14:36
收件人: lining (AD) <lining57@huawei.com>; sunguoshuai <sunguoshuai@huawei.com>
主题: 转发: 【请查收】 关于done->tgt 这个阶段时延的的抓包分析。



发件人: Scandy Li(Gang) 
发送时间: 2018年3月2日 17:13
收件人: Zhengyuehua; chengyu (D); quhuan; weixin (K); Zhouhongbo (C); Zhouchen (C); Xiabingxin
主题: 【请查收】 关于done->tgt 这个阶段时延的的抓包分析。


通过在主机端抓包后，随机选取几个IO进行分析 时延分析：

第一个IO完成到下一个IO发出，主机花费时间为：9.754ms
第一个IO完成到下一个IO发出，主机花费时间为：4.891ms
第一个IO完成到下一个IO发出，主机花费时间为：86us
第一个IO完成到下一个IO发出，主机花费时间为：7.273ms

通过主机端的抓包分析可以看出，主机发出的IO的间隔有大有小，最大可以达到数ms，最小几十us，经过平均以后已经达到ms级，主机上确实存在IO间隔较大的情况，会导致体现在done-》tgt时延上。

1、如图，序号为0x1a328b1c的IO，主机收到回复的时间是：5.505793（单位秒）
 

主机发出下一个IO序号为0x1a328b1d，发出时间是5.515547（秒）
 
主机从上一个收到IO回复到发出下一个IO，主机端花费了9.754ms。

2、如图，序号为0x1a328ab8的IO，主机收到回复的时间是：5.488263（单位秒）
 

主机发出下一个IO序号为0x1a328ab9，发出时间是5.493154（秒）
 
主机从上一个收到IO回复到发出下一个IO，主机端花费了4.891ms。

3、如图，序号为0x1a328bda的IO，完成时间是：5.554818（单位秒）

 

主机发出下一个IO序号为0x1a328bdb，发出时间是5.554904（秒）
 
主机从上一个收到IO回复到发出下一个IO，主机端花费了86us。

4、如图，序号为0x1a3288c4的IO，完成时间是：5.379930（单位秒）
 

主机发出下一个IO序号为0x1a328bdb，发出时间是5.387203（秒）
 
主机从上一个收到IO回复到发出下一个IO，主机端花费了7.273ms。

