
                                  
1.  驱动程序和/proc文件之间的关系：   /proc 下的每个文件都绑到一个“内核函数”上, 当文件被读的时候“即时”产生文件内容.

2.  驱动和内核在代码层面是什么样的关系：
    内核会针对不同的设备提供不通的一套套接口（可以理解成JAVA的接口类），所有的设备都要实现这些接口（这也和JAVA类似），内核不会去管驱动是
    如何实现的，我只提供接口，并按照接口处理数据，提供什么样的数据，就要看你驱动自己的对与错，好与坏了。

3.  有关/proc
    3.1  /proc文件系统的本来目的：  提供关于系统中运行的进程的信息。
    3.2  要创建一个只读 /proc 文件, 你的驱动必须实现一个函数（接口）来在文件被读时产生数据。当某个进程读文件时(使用 read 系统调用), 这个请求通过这个函数
         到达你的模块。
    3.3  当读/proc文件的时候，内核分配一页内存用来存放驱动返回的数据，这些数据是驱动通过自己实现的接口read_proc来获得的，这个接口由内核给出，驱动实现。
          int (*read_proc)(char *page, char **start, off_t offset, int count, int *eof, void *data);
    3.4  这接口需要驱动自己实现，那么在我实现了这个接口后，我需要在/proc目录里面创建一个属于这个接口的文件，并把二者连接到一起。比如：
            create_proc_read_entry("scullmem", 0 /* default mode */,
            NULL /* parent dir */, scull_read_procmem,
            NULL /* client data */);
            这里, 我们创建了一个名为 scullmem 的文件（/proc/scullmem）, 直接在 /proc 下, 带有缺省的, 全局可读的保护。
            这里，create_proc_read_entry就是内核开放给驱动的入口，驱动只要把自己实现的read_proc链接到这个入口函数上就好。
            
4.  ioctl
    首先，ioctl是一个独立的系统调用，通过它，用户可以和内核的驱动程序直接沟通，而不需要内核参与协调。用户程序可以通过这个借口直接访问驱动中的某些内容，
    而不是先调用一些系统函数，再转接到驱动中，再获得想要的内容

5.  《嵌入式linux性能详解》
