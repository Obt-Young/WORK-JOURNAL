++++++++++++++++++++++++++++++++++++++++++++++++++    GDB（编译时无要求加入-g选项）     ++++++++++++++++++++++++++++++++++++++++++++++++++++
#1 - 预备知识，/proc/modules文件中的内容
      文件中存放着所有的内核模块信息，主要有6列：
        nfs      170109  0 -          Live 0x129b0000 
        lockd    51593   1 nfs,       Live 0x128b0000 
        nls_utf8 1729    0 -          Live 0x12830000 
        vfat     12097   0 -          Live 0x12823000 
        fat      38881   1 vfat,      Live 0x1287b000 
        autofs4  20293   2 -          Live 0x1284f000 
        sunrpc   140453  3 nfs,lockd, Live 0x12954000 
        3c59x    33257   0 -          Live 0x12871000 
        uhci_hcd 28377   0 -          Live 0x12869000 
        md5      3777    1 -          Live 0x1282c000 
        ipv6     211845 16 -          Live 0x128de000 
        ext3     92585   2 -          Live 0x12886000 
        jbd      65625   1 ext3,      Live 0x12857000 
        dm_mod   46677   3 -          Live 0x12833000
      第一列：模块名称；第二列：模块的大小（bytes）；第三列：当前模块的实例数；第四列：当前模块依赖于哪个其他模块；
      第五列：模块的当前状态；第六列：模块在内核内存空间的地址，“可以用这个值配合GDB指定启动地址调试程序”。

#2 - 实际操作
      ##1 - 加载模块，modprobe tipc
      ##2 - 获取模块在vmlinux中的偏移地址，cat /proc/modules|grep tipc  ----->   "tipc 121565 0 - Live 0xffffffffa05b2000 (OF)"
      ##3 - 获取tipc模块代码段相对于模块地址的偏移地址，objdump --section-headers tipc.ko|grep text
                                                    ----->   1 .text         00011888  0000000000000000  0000000000000000  00000070  2**4
                                                             2 .init.text    00000126  0000000000000000  0000000000000000  000118f8  2**0
                                                             3 .exit.text    0000004b  0000000000000000  0000000000000000  00011a1e  2**0
                                                             4 .text.unlikely 000008ed  0000000000000000  0000000000000000  00011a69  2**0
      ##4 - 计算在内核代码空间，tipc.ko这个模块的实际代码段起始位置          0xffffffffa05b2000+00000070=0xffffffffa05b2070
      ##5 - 启动GDB，gdb /usr/src/kernels/linux-3.10.107/vmlinux
      ##6 - 指定可运行内核执行文件vmlinux的调试切入点，（在gdb交互环境下）add-symbol-file /usr/lib/modules/3.10.107/kernel/net/tipc/tipc.ko 0xffffffffa057b070
      ##7 - 成功进入tipc的addr.c文件，可使用list查看代码（这里就是问题所在，无法准确到达内核运行启动点module_init(tipc_init)）
      ##8 - 局限性：使用GDB进入内核模块（或内核），只能使用简单的命令，比如list，p等，无法设置断点，甚至都无法使用start或者run 来运行
      ##9 - 鉴于第8条的局限性，下面介绍kgdb和kdb，这两个调试工具可用来执行和调试内核及模块
      
 ++++++++++++++++++++++++++++++++++++++++++++++++++    kdb     ++++++++++++++++++++++++++++++++++++++++++++++++++++     
