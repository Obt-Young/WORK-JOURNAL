#1  进程在执行exec后，会把原先注册了的信号处理函数都复位，还原成默认或者忽略（程序上下文都变了，信号处理函数跟着变也是情理之中）
#2  signal函数应当禁止使用，因为其不是标准实现，每个系统都有自己的实现，而且使用风险极大
#3  fork动作会继承父进程的信号处理函数
#4  早期的信号处理机制，在收到信号并进入信号处理函数之前，内核会先把信号的处理函数设置为默认，而某些信号的默认处理方式是终止进程，那么在
    “信号处理函数中把信号重新注册”和“内核自动置默认”这之间，就有可能因为在此触发信号而导致进行了默认动作。(内核之前由于存在自动设置的机制
    在，所以在编写信号处理函数的时候，会在刚进函数的时候就把信号处理函数再注册一遍)
#5  慢速系统调用 与 中断，如果系统停在一个慢速系统调用中，此时有一个信号发生了，那么此系统调用会返回一个错误码EINTR，表示自己在执行期间
    被一个信号中断了，那么程序应当在此调用此系统调用。
#6  对于#5，因为存在上述问题，所以又如下编程范式：
    again:
        if((n=read(fd,n,buff))<0)
          {
            if(errno=EINTR)
              goto again;
            {other wrong dealing}
          }
    针对如上会被中断打断的系统调用情况，内核提供了自动恢复机制，这样就不用处理EINTR错误码，内核在检测到系统调用错误后，首先会检查错误码是不是
    EINTR，如果是就继续系统调用，这样用户就不用处理EINTR了。但是有些时候，就是想处理这些错误码，那么可以再sigaction中设置，把这个机制打开或者
    关闭。   这里的系统调用指慢速系统调用，比如read，write，ioctl，wait，waitpid，readv，writev。（以后尽量使用sigaction而不是signal）
#7  注意:在进入信号处理函数之前，千万要先保存errno的值，因为在信号处理函数中，这个值可能会被改变。
        设置的方法：进入终端处理函数就把这个值赋值给一个局部变量，在离开终端处理函数之前再把这个值赋值给errno
#8  什么是“可重入函数”？进入中断处理函数后，使用这些函数，不会导致系统的数据区发生改变的函数。比如malloc就不行，如果在进中断之前做了malloc，然后
    这个函数刚执行一般，被一个中断插进来，而且又在中断中使用了malloc，那么从中断中出来后，外面的malloc将会失败。   
      有一个可重入函数的列表，大致总结下就是，凡是使用了malloc和free的，全是不可重入函数，非系统调用的I/O函数基本上全是不可重入(因为他们肯定会
      使用malloc和free)
#9  SIGCHLD，如果子进程的“状态”发生了改变，父进程需要调用wait函数来查看下子进程怎么了。不是说子进程只有在退出时才会发这个信号
#10 






    
