GBD调试的前提：编译时使用-g选项/安装了待调试软件的debuginfo包（debuginfo-install 从yum源中安装）
-----------------------------------------------------------------------------------------------------------
启动并调试：            gdb program
带core文件启动并调试：   gdb program core  （执行后，停在哪，系统就down在哪）
调试一个运行中的进程：   gdb program 1234  / gdb - 1234
过滤gdb产品信息运行gdb：    gdb --silent
在gdb环境中运行shell命令：  shell ls
在gdb环境中运行make命令：   make all
转移gdb输出到文件中：set logging on      set logging file filename
                    （https://sourceware.org/gdb/current/onlinedocs/gdb/Logging-Output.html#Logging-Output）
                    
                    
#1  - 命令补全，和shell一样，用TAB补全，同样有双击TAB罗列可选项的功能

#2  - 基本命令
      run     启动程序 
      start   主函数处设置断点，启动程序，每次过来执行都会停住，相当于一个长期断点
      starti  主函数处设置断点，启动程序，仅在第一个过来执行时会挺住，相当于一次性断点
      set args  设置运行参数，进入交互界面后，set args arg1 arg2，依次设置参数1——arg1 和 参数2——arg2
      show args 查看已设置的参数
      continue  一直执行，知道下一个断点，若无断点，则一直执行到程序结束
      bt      输出当前调用栈
      n       step over 
      s       step into
      
      break   设置断点
                break lineno                      当前文件的指定行处
                break filename:lineno             特定文件的指定行处
                break functionname                当前文件的指定函数入口
                break filename:functionname       特定文件的指定函数入口
                break *address                    某个虚拟地址
                break                             下一条指令处
                break ... if xxx                  满足xxx条件，停在...处（...为上面提到的lineno、functionname等等）
                                                  比如：break printf if i>100
      info    查看相关信息
                info break                        查看断点信息
                info threads                      查看线程信息
                info r                            查看寄存器信息
                
      condition 为断点加条件（类似于break ... if xxx，更细化）
                假设已经设置了断点3
                condition 3 a>10                  当a>10的时候，在3号断点停住
                condition 3                       清除加在3号断点上的条件（比如上面的a>10）
                
      ignore 3 100                                进入断点3的前100次将被忽略，从101次开始断点才有效                
            
                                          
#3  - 多进程调试
      默认情况下，gdb跟踪父进程
      可以在任何时候设置跟踪子进程：set follow-fork-mode childe
      
      那么exec系列函数是否能够使用gdb跟踪呢？
      
#4  - 多线程调试
      info threads    查看所有线程（其中带*号的为当前线程）
      thread 2        切换到2号线程
      where           输出线程调用栈（对应bt）
      break ... thread 2  为2号线程打上断点（...为之前提到的lineno、functionname等等）
-----------------------------------------------------------------------------------------------------------
如何配置才能在进程core dump 时生成core文件
ulimit -c unlimited 不限制生成core文件大小 
echo “/corefile/core-%e-%p-%t” > /proc/sys/kernel/core_pattern 
【注意】这种配置不是永久有效

为什么加了有debuginfo ，调试的时候有些地方仍然没有debug信息
  -g 选项默认不会包括一些宏定义的信息
  可以在编译时使用-g3


















      
