
#1  如果发生某种错误时，如某个路由器暂时用完了缓冲区， I P有一个简单的错误处理算法：丢弃该数据报，然后发送I C M P消息报给信源端

#2  从前面有关以太网帧的介绍，IP头是20个字节，下面对这20个字节做一下细分：
        
          版本（4bit）  | IP首部长度（4bit）|  服务类型TOS值（8bit）| ip packet的总长度=IP首部+TCP segment（16位）            ---->类型和长度
          标识（16bit）                                           |  标志（3bit）  | 偏移（13bit）                          ---->分片和重组
          TTL （8bit）  |   协议（8bit）                          |  IP头校验和（16bit）
          源IP地址（32bit）
          目的IP地址（32bit）
          
          * 注 ：高位在左边，低位在右边
                 IP首部长度 = IP头 + 任意长度的选项
                 （IP头的长度是一定的，任意长度选项的长度可变，但是范围受限，因为IP首部4bit只能表示60个字节）
          
#3  服务类型TOS值：一共8bit，其中有4个bit被忽略，只用剩下的那4个bit，这4个bit作为位图，每一个bit位都表示不同的含义，分别是
                  使用最小延迟传输、使用最大吞吐量传输、使用最高可用性传输、使用最小费用传输。
           *注 ： 对于不同的协议（FTP,SMTP,TCP,UDP,DNS等等），IP头中的这个字段都有一个默认最佳值，这也是根据各个协议的特性给出的默认值

#3  ip packet的总长度 = IP首部 + TCP segment = IP 头 + 选项 + TCP segment
        IP总长度字段为16位，因此一个送给链路层的IP packet的最大长度为65535个字节，这也是前面提到的超通道的最大MTU

#4  标识：唯一地标识主机发送的每一分ip packet，每发送一个，就加1，在分片和重组的时候会介绍这个

#5  TTL：ip packet可以经过最多的路由器“个数”，这是一个设置好以后逐次递减的值，每经过一个路由器，这个值都要减1，当减到0，包被抛弃，同时发送ICMP报文通知
          源IP地址。（那ICMP是不是不会被抛弃，一定会送达？）
        （可以通过修改路由器上的IP协议层，让这个值不减，这样就可会导致包不会被抛弃）
        
#6  IP头校验和：通过一个计算方法（blabla.....），获得一个值附加在这里，对端收到以后会校验，如果校验不通过，那么这个包会被当做错包抛弃，但是不同于TTL
                的处理，被抛弃时，不会发送差错报文（ICMP）给源IP地址，由上层应用来决定怎么做。
         （相当于在应用层判断处理方法，先把包拿下来，说明这个包已经正确送达，后面发现校验字段错了，那么有应用层决定是否相信这个校验字段错误的数据包）
         
#7  一般情况下，IP层会受到的数据来自于两个入口：
              1）本机上层封装的，要使用IP协议发送出去的数据，比如来自tcp，udp，icmp，igmp等的数据segment。（这里为源发者的角色，可以理解为主机）
              2）从一个接口收收据入本机，然后通过另一个接口发送出去。                                （这里为转发者的角色，可以理解为路由器）
          
#8   IP层在内存中有一个“路由表”，IP协议每次收到一个packet，都要搜索此表，如果：
                1）IP头中的“目的IP地址”是否等于“本机IP地址之一（因为本机可能有多个IP）”或者“IP广播地址”，如果是，那么这个包是给我的，我自己处理，
                   具体送到协议栈进一步解包，要看 IP头中的 “协议（8bit）”字段；
                2）如果不满足1）中描述的，那么需要进一步判断：IP层被设置成路由器了？是，则转发出去；否，则抛弃此包。
                
#9   路由表的字段：目的IP地址，下一站路由的ip地址，标志，为数据包传输指定一个网络接口

#10  搜索路由表会有如下动作：1）-- ip packet.目的ip地址 = 路由表.目的ip地址 ，把包送过去，结束
                           2）-- 1）失败，ip packet.目的ip地址.网络号（ip地址的五个分类中有描述） = 路由表.目的ip地址.网络号，把包送过去，让
                                 下一个节点重复1）
                           3）-- 2）也失败，查找路由表中标注为默认（default）的条目，如果找到了，就发送给这个条目的ip地址
                           4）-- 3）也没找到，那么这个数据包无法被发出去，如果该数据包是本机器的，那么直接反一个“主机不可达”或“网络不可达”的错误
                                 给应用程序。
                *注 ： 综上，取出packet中的目的ip地址后，现在路由表中找一样的ip；找不到的话，再找一样的网络号（ip地址中间那段，见前面描述）；还找
                       不到的话，再找默认条目；还是没有的话，这个包就发不出去了。
                       
        一般情况下，路由表中大多是网络号条目，这样可以缩小路由表的规模，但是对应的就是可能要多转发几次，这也是一个此消彼长的问题，条目过于细化，在
        初期查询时浪费时间，过于粗糙，转发的次数就可能比较多。

#11  小结：
        1）一个数据包被某个节点（可以是路由器，也可以是主机）收到以后，首先被解出IP头中的目的IP地址字段，和本节点的路由表进行#10的对比；
        2）在对比的过程中，如果对不上，那么检查下当前主机是否可被用作路由，或者是否是路由器（其实这两者一样，都是当前设备上跑的IP协议栈是否可被用作
           路由功能）；
        3）在发送到以太网上的以太网帧头中有一个IP地址，这个地址的值为下一个路由点的值，这个值在消息的整个传送过程中应该是不停变化的，是用来找下一个
           路由点的，和IP头中的目的IP地址不是一回事，要区分开，IP头中的地址是消息的最终落地点，不会变；
        4）以太网帧头中的那个IP地址是通过ARP协议实时获取的，不是存在内存中，或者哪个数据结构中的。



=====================================================   子网   =====================================================
#1      子网的定义：
                先看五类IP  --           A：   0（1bit）|网络号（7bit）|主机号（24bit）
                                        B：   10（2bit）|网络号（14bit）|主机号（16bit）
                                        C：   110（3bit）|网络号（21bit）|主机号（8bit）
                                        D：   1110（4bit）|多播组号（28bit）
                                        E：   11110（5bit）|还没使用（27bit）
                所谓子网，就是在当前五类ip的基础上再细分一下，把  “主机号”  再分成  “子网网络号” 和 “子网主机号”,比如：
                
                B：   10（2bit）|网络号（14bit）|子网网络号（8bit）|子网主机号（8bit）
                     这里把B网再划分，16bit的主机号，人为定义8bit子网网络号 和 8bit子网主机号，这样就允许在当前网络下再有254个子网，每个子网
                     有254个主机，即254*254个ip

#2      子网掩码：#1中描述了对于B类地址，可以把16位主机号分成8+8的结构，这是人为定义的，那么如果换一个人，可能就是4+12,12+4，6+10等等，为了
                 知道是什么样的划分，子网掩码的感念就被引入了。
                 掩码是32bit的，和ip地址长度一样，举个例子，对于B类地址，可以有如下两种子网掩码，分别表示了两种划分方法：
                   （1留给网络号和子网号，0留给主机号）
                             网络号         子网号     主机号
                        11111111 11111111 11111111 00000000     255.255.255.0                   8bit子网=256-2个子网
                                                                                                8bit主机=256-2个主机/子网
                                                                                                总ip数=254*254=64516
                        
                             网络号         子网号     主机号                                    
                        11111111 11111111 11111111 11000000    255.255.255.192                  10bit子网=1024-2个子网
                                                                                                6bit主机=64-2个主机/子网
                                                                                                总ip数=1022*62=63364
                                                                                                
                    *注  ：  这里的ip地址值其实不直观，最直观还是要看2进制，先看有n个0，那就有2^n个主机，2^(16-n)个子网


#3      小结：子网掩码定义了ip地址如何划分，如果要确认两个ip地址是否处于一个子网，必须要知道子网掩码才行，比如：
                140.252.13.35  和  140.252.13.66
              1）如果子网掩码为255.255.255.0，那么网络号和主机号是8+8划分的，那么这两个ip的网络号都是13，主机号分别是35和66，则是在一个子网内的；
              2）如果子网掩码为255.255.255.224，那么网络和和主机号是12+4划分的，那么第一个ip的网络号是416（000011010000），主机号是3（0011）
                                                                               第二个ip的网络号是210（000011010010），主机号是1（0001）
                 


#4      netstat -in 查看接口信息，其中包括M T U、输入分组数、输入错误、输出分组数、输出错误、冲突以及当前的输出队列长度。








                
                
                
                
                   
