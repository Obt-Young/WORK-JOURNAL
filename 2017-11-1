1.  创建自己的/proc文件
        可通过  struct proc_dir_entry *create_proc_read_entry(const char *name,
                                                              mode_t mode,
                                                              struct proc_dir_entry *base,
                                                              read_proc_t *read_proc,
                                                              void *data);    来创建。
        P1  ---  想要创建的文件的名称（不是全路径，仅仅是名称）
        P2  ---  文件保护掩码（0表示使用默认值）
        P3  ---  该文件所在的目录（如果为NULL，则表示创建在/proc目录下）
        P4  ---  驱动需要实现的接口，这个参数也是这个函数的核心点，
        P5  ---  这个参数内核不管，这个参数会传给P4
-----------------------------------------------------------------------------------------------这个函数在3.10的内核完后就被去除了
                                                                                               改用proc_create,参数也有所改变，具
                                                                                               体使用的话就看相关手册



                                                            
2.  在创建模块（驱动）的时候，如果需要自己的proc文件，那么可以通过上面那个函数创建，但是卸载模块的时候，千万别忘了使用remove_proc_entry把已创建
    的proc文件删除。    注意：如果删除入口项（proc文件）失败，将导致未预期的调用，如果模块已被卸载了
                                            那么---------“内核将会崩溃！！！！”-----------
                                            
3.  内核对于驱动程序是信任的，因此不会对驱动程序做一些合规性的检查。

4.  strace命令，可用来查看一个可执行文件的系统调用情况。使用方法：strace ./1    strace ls
        
5.  大部分错误都是因为对NULL指针取值或者因为使用了其他不正确的指针值。这些错误通常会导致一个oops错误。
    
    oops产生的原因：当引用一指针时，分页机制将虚拟地址映射到物理地址上，这时候，按照常理CPU会产生一个缺页信号给OS，要求把相应的页还如内
                   存，但是这时候发现要访问的地址是非法的，内核就拒绝CPU的这个动作，如果此时CPU处在超级用户模式，就会产生一个oops。
                   
    如何处理oops：通常在遇到oops的时候，我们首先找到发生的问题所在的位置，这个信息通常就在oops的输出里————“EIP is at xxxxxxx”
    
6.  使用GDB调试内核
        gdb  /usr/src/linux/vmlinux  /proc/kcore                        （第一个是未经压缩的内核ELF可执行文件的名字）
    对于正在运行的内核，所谓的core文件就是这个内核在内存中的核心镜像，即/proc/kcore
    
7.  使用kdb调试内核

8.  用户模式的linux虚拟机

9.  主设备号和次设备号
        主设备号：标识设备对应的驱动程序。
        次设备号：由内核使用，用于正确确定设备文件所指的设备。反过来想，我们也可以利用次设备号获取一个指向设备的指针。
        
    内核中，dev_t用来保存设备号（主设备和次设备）




    
                   
