1.  创建自己的/proc文件
        可通过  struct proc_dir_entry *create_proc_read_entry(const char *name,
                                                              mode_t mode,
                                                              struct proc_dir_entry *base,
                                                              read_proc_t *read_proc,
                                                              void *data);    来创建。
        P1  ---  想要创建的文件的名称（不是全路径，仅仅是名称）
        P2  ---  文件保护掩码（0表示使用默认值）
        P3  ---  该文件所在的目录（如果为NULL，则表示创建在/proc目录下）
        P4  ---  驱动需要实现的接口，这个参数也是这个函数的核心点，
        P5  ---  这个参数内核不管，这个参数会传给P4
-----------------------------------------------------------------------------------------------这个函数在3.10的内核完后就被去除了
                                                                                               改用proc_create,参数也有所改变，具
                                                                                               体使用的话就看相关手册



                                                            
2.  在创建模块（驱动）的时候，如果需要自己的proc文件，那么可以通过上面那个函数创建，但是卸载模块的时候，千万别忘了使用remove_proc_entry把已创建
    的proc文件删除。    注意：如果删除入口项（proc文件）失败，将导致未预期的调用，如果模块已被卸载了
                                            那么---------“内核将会崩溃！！！！”-----------
                                            
3.  内核对于驱动程序是信任的，因此不会对驱动程序做一些合规性的检查。

4.  strace命令，可用来查看一个可执行文件的系统调用情况。使用方法：strace ./1    strace ls
        
5.  大部分错误都是因为对NULL指针取值或者因为使用了其他不正确的指针值。这些错误通常会导致一个oops错误。
    
    oops产生的原因：当引用一指针时，分页机制将虚拟地址映射到物理地址上，这时候，按照常理CPU会产生一个缺页信号给OS，要求把相应的页还如内
                   存，但是这时候发现要访问的地址是非法的，内核就拒绝CPU的这个动作，如果此时CPU处在超级用户模式，就会产生一个oops。
                   
    如何处理oops：通常在遇到oops的时候，我们首先找到发生的问题所在的位置，这个信息通常就在oops的输出里————“EIP is at xxxxxxx”
    
6.  使用GDB调试内核
        gdb  /usr/src/linux/vmlinux  /proc/kcore                        （第一个是未经压缩的内核ELF可执行文件的名字）
    对于正在运行的内核，所谓的core文件就是这个内核在内存中的核心镜像，即/proc/kcore
    
7.  使用kdb调试内核

8.  用户模式的linux虚拟机

9.  主设备号和次设备号
        主设备号：标识设备对应的驱动程序。
        次设备号：由内核使用，用于正确确定设备文件所指的设备。反过来想，我们也可以利用次设备号获取一个指向设备的指针。
        
    内核中，dev_t用来保存设备号（主设备和次设备）


10.  内核模块与应用程序的对比
   10.1)内核模块具有独立的地址空间 
     模块运行在内核空间中。应用程序运行在用户空间中。系统软件受到保护，不允许用户程序访问。内核空间和用户空间有各自独立的内存地址空间。 
   10.2)内核模块具有更高的执行特权
     运行在内核空间中的代码要比运行在用户空间中的代码具有更大的特权。由于驱动程序模块对系统的影响要远远大于对用户程序的影响，所以请认真、全面地测试驱动
   程序模块，以避免为系统带来负面的影响。  
   10.3)内核模块不按顺序执行 
      用户程序通常按顺序执行并且从头到尾地执行单独的任务。内核模块并不按顺序执行，它注册自己是为了服务将来的请求。 
      
11.  LKCD(Linux Kernel Crash Dump)
    当内核发生panic时，它会把当前系统状态信息（主要指内存）写入事先指定好的转储设备中。
    根据存储设备的不同，LKCD可以分为两种类型，disk dump和net dump。对于disk dump这个转储设备必须是一个独立的分区，通常可以设置为系统交换区，在
系统panic时用来存入状态信息，在下次重启时（在存储交换功能开启之前）系统会运行一个称为 LCRASH 的工具来生成崩溃的概要记录，并可选择地把转储的
复本保存在一个普通文件中。 
      



    
                   
