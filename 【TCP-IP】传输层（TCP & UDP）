IP数据包  和  IP packet的关系：IP数据包是指应用数据，这个数据可能会很大，需要分片，所以一个数据包大于等于一个packet，一个packet指一个
                             Frame中的应用数据部分，所以一个packet 等于 一个fragment

=======================================UDP==============================================
#1  NFS使用UDP协议
#2  UDP协议头中的校验和字段，可填可不填，具体要看协议是否开启此功能，校验和主要用来确认数据包是否被篡改
#3  可以使用tcpdump查看校验和，如果校验和为0，则代表关闭了校验和功能
#4  （！）尽量避免使用分片(送给IP的应用数据不要超过MTU)  ----  如果某个IP数据包（不是packet，）的fragment其中一个在传输中丢失了，那么整个数据包
          都要重传！
#5  一个IP数据被分片传输后，有可能在到达对端时在时间上是失序的，但是IP头中有序列，所以没关系，还是能被正确组装起来
#6  DNS TFTP BOOTP SNMP 协议都使用UDP协议作为底层


=======================================TCP==============================================
#1  TCP提供面向连接可靠的数据“流”服务，应用数据被分割成TCP认为最合适发送的数据块大小进行发送，这个数据块称为“segment”
#2  当TCP发送一个segment后，它启动一个定时器，等待目的端回应确认收到报文的应答。如果超时未收到，则重发此segment。在收到对端的应答后，本端在等待
    零点几秒（认为要求）后，再发送一个确认segment给对端。
#3  TCP头中有一个校验和字段，如果这个值不正确，则认为此segment有问题，当做废包，等待对端的超时重发
#4  对于失序到达的segment，TCP会重新组装成正确的顺序，再呈现给应用层。
#5  IP packet可能会出现重复，那么TCP就应当有一个丢弃重复数据的机制，很幸运，是有的。
#6  TCP有流量控制机制，TCP连接的每一方都有固定大小的缓冲空间。
    TCP只允许另一端发送接收缓冲区所能容纳的数据。（这个协商过程是怎么做的？？？）

#7      TCP头：
                                      源端口号       |       目的端口号
                                      （16bit）      |        （16bit）
                                                 序号（32bit）
                                               确认序号（32bit）
   首部长度（4bit）|reserve（6bit）|UGR|ACK|PSH|RST|SYN|FIN|        窗口大小（16bit）
                                   校验和（16bit）         |       紧急指针（16bit）
                                                  可选字段(nbit)
                                   
#8  32bit的需要用来标识发端向收端发送的字节的编号，比如两个segment，第一个segment有100个字节，那么第二个segment的序号域为101。范围0~（2^32）-1,满后归0

#9  U R G 紧急指针（ u rgent pointer）有效。
    A C K 确认序号有效。
    P S H 接收方应该尽快将这个报文段交给应用层。
    R S T 重建连接。
    S Y N 同步序号用来发起一个连接。这个标志和下一个标志将在第1 8章介绍。
    F I N 发端完成发送任务。
    
#10 T C P的流量控制由连接的每一端通过声明的窗口大小来提供。
    窗口大小为字节数，起始于确认序号字段指明的值，“这个值是接收端正期望接收的字节”。
    窗口大小是一个16 bit字段，因而窗口大小最大为6 5 5 3 5字节
    
#11 校验和由TCP segment（TCP头+TCP数据）求得。

#12 U R G 紧急指针（ u rgent pointer），此为一个“字节偏移量”，和序号字段相加标识紧急数据最后一个字节的序号。

#13   Maximum Segment Size(MSS),双方都在通讯的第一个报文（SNY的时候）中指定这个值，用来表示自己能一次性收到的最大的segment的长度
      MSS，在双方做SNY时才会添加，用来告知对方自己能接受的最大的segment大小，超过这个大小的segment，接收端不会收，而是通过？？机制
      告知对方————“你发的segment超过我的MSS了”（解释了#6中的疑问）
      此字段存在的意义在于“尽量避免分片的产生”（如何避免的？）
      小结：TCP每个segement大小都是一致的？（除了最后一个segment？）
    
    
#14 TCP是一个“不可选择性确认（ACK）的，且不具备否定能力的”滑动窗口协议。
    不可选择性确认：对于发送端发的请求，接收端的应答报文只能应答这个请求，而不能指定应答别的请求，可以理解为“严格按顺序进行”
    不具备否定能力：接收端的应答只能是“我收到了序号i到j的segment”，而不能是“我没收到序号是k的segment”，对于如何告知发送端
                   “没收到”这件事，是通过重复发送“我收到了序号i到j的segment”来完成的
                   
          注：上面这两个特点很重要，他概述了TCP是对于传输控制，是如何“曲线救国”的，而不是不停地“加字段”导致协议膨胀

#15 对于三次握手：1）发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并回复一个SYN的一端将执行被动打开（passive open），
                    后面还会有其他方法来实现双方都主动打开。
                 2）当一个连接建立时，发送第一个SYN的一端会根据当前时间穿件一个起始序号（ISN）（一个很大的数值），后面的通讯都基于
                    这个序号向后扩展。
                    
    小结：可以这样理解，有一个计时器不停地生产ISN值，当TCP需要ISN值的时候就去拿一个出来用，后面的一系列通讯就不再到这里面
          拿值了，这个值每4ms会加1，系统启动时就在不停的增长（一段时间后会归0）。切记，仅仅在第一个SYN时候会使用，后面的
          通讯就自己维护这个值了。
          如何进行序号选择? 在4 . 4 B S D（和多数的伯克利的实现版）中，系统初始化时初
          始的发送序号被初始化为1。这种方法违背了Host Requirements RFC（在这个代码中的
          一个注释确认这是一个错误）。这个变量每0 . 5秒增加6 4 0 0 0，并每隔9 . 5小时又回到0
          （对应这个计数器每8 ms加1，而不是每4 ms加1）。另外，每次建立一个连接后，这个变量将增加64000。                 

#16 和建立连接一样，断开连接也需要双方的确认，当某个














